// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: adventures.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAdventure = `-- name: GetAdventure :one
SELECT products.id, kind, title, title_ar, description, description_ar, photo, price_omr, last_udpated, a.id, a.available_dates, adventures.id, adventures.available_dates, r.product_id, r.user_id, r.review, r.last_updated, reviews.product_id, reviews.user_id, reviews.review, reviews.last_updated, users.id, email, firstname, lastname, phone,
(SELECT COUNT(*) FROM purchases p WHERE p.product_id=$1) purchases,
(SELECT COUNT(*) FROM purchases p WHERE p.product_id=$1 AND p.user_id=$2) user_purchases,
(SELECT SUM(ratings)/COUNT(*) as rating FROM ratings r WHERE r.product_id=$1) rating,
(SELECT rating FROM ratings r WHERE r.product_id = $1 AND r.user_id=$2) rating
FROM products NATURAL JOIN (SELECT id, available_dates FROM adventures WHERE adventures.id = $1) a
INNER JOIN (SELECT product_id, user_id, review, last_updated FROM reviews WHERE product_id = $1) r ON a.id = product_id
INNER JOIN users ON r.user_id = users.id
`

type GetAdventureParams struct {
	ProductID uuid.UUID `json:"product_id"`
	UserID    uuid.UUID `json:"user_id"`
}

type GetAdventureRow struct {
	ID               uuid.UUID   `json:"id"`
	Kind             string      `json:"kind"`
	Title            string      `json:"title"`
	TitleAr          string      `json:"title_ar"`
	Description      string      `json:"description"`
	DescriptionAr    string      `json:"description_ar"`
	Photo            string      `json:"photo"`
	PriceOmr         float64     `json:"price_omr"`
	LastUdpated      time.Time   `json:"last_udpated"`
	ID_2             uuid.UUID   `json:"id_2"`
	AvailableDates   []time.Time `json:"available_dates"`
	ID_3             uuid.UUID   `json:"id_3"`
	AvailableDates_2 []time.Time `json:"available_dates_2"`
	ProductID        uuid.UUID   `json:"product_id"`
	UserID           uuid.UUID   `json:"user_id"`
	Review           string      `json:"review"`
	LastUpdated      time.Time   `json:"last_updated"`
	ProductID_2      uuid.UUID   `json:"product_id_2"`
	UserID_2         uuid.UUID   `json:"user_id_2"`
	Review_2         string      `json:"review_2"`
	LastUpdated_2    time.Time   `json:"last_updated_2"`
	ID_4             uuid.UUID   `json:"id_4"`
	Email            interface{} `json:"email"`
	Firstname        string      `json:"firstname"`
	Lastname         string      `json:"lastname"`
	Phone            string      `json:"phone"`
	Purchases        int64       `json:"purchases"`
	UserPurchases    int64       `json:"user_purchases"`
	Rating           int32       `json:"rating"`
	Rating_2         float64     `json:"rating_2"`
}

func (q *Queries) GetAdventure(ctx context.Context, arg GetAdventureParams) (GetAdventureRow, error) {
	row := q.db.QueryRowContext(ctx, getAdventure, arg.ProductID, arg.UserID)
	var i GetAdventureRow
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Title,
		&i.TitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.Photo,
		&i.PriceOmr,
		&i.LastUdpated,
		&i.ID_2,
		pq.Array(&i.AvailableDates),
		&i.ID_3,
		pq.Array(&i.AvailableDates_2),
		&i.ProductID,
		&i.UserID,
		&i.Review,
		&i.LastUpdated,
		&i.ProductID_2,
		&i.UserID_2,
		&i.Review_2,
		&i.LastUpdated_2,
		&i.ID_4,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
		&i.Phone,
		&i.Purchases,
		&i.UserPurchases,
		&i.Rating,
		&i.Rating_2,
	)
	return i, err
}

const getAllAdventures = `-- name: GetAllAdventures :many
SELECT products.id, kind, title, title_ar, description, description_ar, photo, price_omr, last_udpated, adventures.id, available_dates, l.rating, l.product_id, ratings.product_id, user_id, created_at, ratings.rating
FROM products NATURAL JOIN adventures
INNER JOIN (SELECT SUM(ratings)/COUNT(*) as rating, product_id FROM ratings GROUP BY product_id) l ON products.id = l.product_id
`

type GetAllAdventuresRow struct {
	ID             uuid.UUID   `json:"id"`
	Kind           string      `json:"kind"`
	Title          string      `json:"title"`
	TitleAr        string      `json:"title_ar"`
	Description    string      `json:"description"`
	DescriptionAr  string      `json:"description_ar"`
	Photo          string      `json:"photo"`
	PriceOmr       float64     `json:"price_omr"`
	LastUdpated    time.Time   `json:"last_udpated"`
	ID_2           uuid.UUID   `json:"id_2"`
	AvailableDates []time.Time `json:"available_dates"`
	Rating         int32       `json:"rating"`
	ProductID      uuid.UUID   `json:"product_id"`
	ProductID_2    uuid.UUID   `json:"product_id_2"`
	UserID         uuid.UUID   `json:"user_id"`
	CreatedAt      time.Time   `json:"created_at"`
	Rating_2       float64     `json:"rating_2"`
}

func (q *Queries) GetAllAdventures(ctx context.Context) ([]GetAllAdventuresRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAdventures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAdventuresRow{}
	for rows.Next() {
		var i GetAllAdventuresRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Title,
			&i.TitleAr,
			&i.Description,
			&i.DescriptionAr,
			&i.Photo,
			&i.PriceOmr,
			&i.LastUdpated,
			&i.ID_2,
			pq.Array(&i.AvailableDates),
			&i.Rating,
			&i.ProductID,
			&i.ProductID_2,
			&i.UserID,
			&i.CreatedAt,
			&i.Rating_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAdventure = `-- name: UpsertAdventure :exec
WITH upsert_product AS (
  INSERT INTO products(id, kind, title, title_ar, description, description_ar, photo, price_omr)
  VALUES ($1, 'A', $2, $3, $4, $5, $6, $7)
  ON CONFLICT (id) DO UPDATE SET
    title = excluded.title,
    title_ar = excluded.title_ar,
    description = excluded.description,
    description_ar = excluded.description_ar,
    photo = excluded.photo,
    price_omr = excluded.price_omr
)
INSERT INTO adventures(id, available_dates)
VALUES ($1, $8)
ON CONFLICT (id) DO UPDATE SET
	available_dates=excluded.available_dates
`

type UpsertAdventureParams struct {
	ID             uuid.UUID   `json:"id"`
	Title          string      `json:"title"`
	TitleAr        string      `json:"title_ar"`
	Description    string      `json:"description"`
	DescriptionAr  string      `json:"description_ar"`
	Photo          string      `json:"photo"`
	PriceOmr       float64     `json:"price_omr"`
	AvailableDates []time.Time `json:"available_dates"`
}

func (q *Queries) UpsertAdventure(ctx context.Context, arg UpsertAdventureParams) error {
	_, err := q.db.ExecContext(ctx, upsertAdventure,
		arg.ID,
		arg.Title,
		arg.TitleAr,
		arg.Description,
		arg.DescriptionAr,
		arg.Photo,
		arg.PriceOmr,
		pq.Array(arg.AvailableDates),
	)
	return err
}
