// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: products.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const completePurchase = `-- name: CompletePurchase :exec
UPDATE purchases SET complete=true WHERE id=$1
`

func (q *Queries) CompletePurchase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, completePurchase, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products SET is_deleted = true WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductReview = `-- name: DeleteProductReview :exec
DELETE FROM reviews WHERE product_id = $1 AND user_id = $2
`

type DeleteProductReviewParams struct {
	ProductID string    `json:"product_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteProductReview(ctx context.Context, arg DeleteProductReviewParams) error {
	_, err := q.db.Exec(ctx, deleteProductReview, arg.ProductID, arg.UserID)
	return err
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT available_products.id, available_products.kind, available_products.title, available_products.title_ar, available_products.subtitle, available_products.subtitle_ar, available_products.description, available_products.description_ar, available_products.photo, available_products.price_baisa, available_products.planned_dates, available_products.photos, available_products.longitude, available_products.latitude, available_products.last_updated, available_products.is_deleted, r.rating, r.rating_count, review.review_count
FROM available_products
LEFT JOIN (SELECT  COALESCE(SUM(rating)/COUNT(*), 0) as rating, product_id, COALESCE(COUNT(*), 0)  AS rating_count FROM reviews GROUP BY product_id) r ON available_products.id = r.product_id
LEFT JOIN (SELECT  COALESCE(COUNT(*), 0) as review_count, product_id FROM reviews WHERE title != '' GROUP BY product_id) review ON available_products.id = review.product_id
`

type GetAllProductsRow struct {
	ID            string      `json:"id"`
	Kind          string      `json:"kind"`
	Title         string      `json:"title"`
	TitleAr       string      `json:"title_ar"`
	Subtitle      string      `json:"subtitle"`
	SubtitleAr    string      `json:"subtitle_ar"`
	Description   string      `json:"description"`
	DescriptionAr string      `json:"description_ar"`
	Photo         string      `json:"photo"`
	PriceBaisa    int64       `json:"price_baisa"`
	PlannedDates  []time.Time `json:"planned_dates"`
	Photos        []string    `json:"photos"`
	Longitude     float64     `json:"longitude"`
	Latitude      float64     `json:"latitude"`
	LastUpdated   time.Time   `json:"last_updated"`
	IsDeleted     bool        `json:"is_deleted"`
	Rating        interface{} `json:"rating"`
	RatingCount   interface{} `json:"rating_count"`
	ReviewCount   interface{} `json:"review_count"`
}

func (q *Queries) GetAllProducts(ctx context.Context) ([]GetAllProductsRow, error) {
	rows, err := q.db.Query(ctx, getAllProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductsRow{}
	for rows.Next() {
		var i GetAllProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Title,
			&i.TitleAr,
			&i.Subtitle,
			&i.SubtitleAr,
			&i.Description,
			&i.DescriptionAr,
			&i.Photo,
			&i.PriceBaisa,
			&i.PlannedDates,
			&i.Photos,
			&i.Longitude,
			&i.Latitude,
			&i.LastUpdated,
			&i.IsDeleted,
			&i.Rating,
			&i.RatingCount,
			&i.ReviewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPurchases = `-- name: GetAllPurchases :many
SELECT purchases.id, product_id, user_id, num_of_participants, paid, cost_baisa, chosen_date, complete, created_at, extra_price_chosen, products.id, kind, title, title_ar, subtitle, subtitle_ar, description, description_ar, photo, base_price_baisa, planned_dates, photos, longitude, latitude, last_updated, is_deleted, extra_price_baisa, users.id, email, phone, role, name FROM purchases
INNER JOIN products on purchases.product_id = products.id
INNER JOIN users on users.id = purchases.user_id
WHERE complete = true
ORDER BY purchases.chosen_date
`

type GetAllPurchasesRow struct {
	ID                uuid.UUID   `json:"id"`
	ProductID         string      `json:"product_id"`
	UserID            uuid.UUID   `json:"user_id"`
	NumOfParticipants int32       `json:"num_of_participants"`
	Paid              bool        `json:"paid"`
	CostBaisa         int64       `json:"cost_baisa"`
	ChosenDate        time.Time   `json:"chosen_date"`
	Complete          bool        `json:"complete"`
	CreatedAt         time.Time   `json:"created_at"`
	ExtraPriceChosen  bool        `json:"extra_price_chosen"`
	ID_2              string      `json:"id_2"`
	Kind              string      `json:"kind"`
	Title             string      `json:"title"`
	TitleAr           string      `json:"title_ar"`
	Subtitle          string      `json:"subtitle"`
	SubtitleAr        string      `json:"subtitle_ar"`
	Description       string      `json:"description"`
	DescriptionAr     string      `json:"description_ar"`
	Photo             string      `json:"photo"`
	BasePriceBaisa    int64       `json:"base_price_baisa"`
	PlannedDates      []time.Time `json:"planned_dates"`
	Photos            []string    `json:"photos"`
	Longitude         float64     `json:"longitude"`
	Latitude          float64     `json:"latitude"`
	LastUpdated       time.Time   `json:"last_updated"`
	IsDeleted         bool        `json:"is_deleted"`
	ExtraPriceBaisa   int64       `json:"extra_price_baisa"`
	ID_3              uuid.UUID   `json:"id_3"`
	Email             string      `json:"email"`
	Phone             string      `json:"phone"`
	Role              UserRole    `json:"role"`
	Name              string      `json:"name"`
}

func (q *Queries) GetAllPurchases(ctx context.Context) ([]GetAllPurchasesRow, error) {
	rows, err := q.db.Query(ctx, getAllPurchases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPurchasesRow{}
	for rows.Next() {
		var i GetAllPurchasesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.NumOfParticipants,
			&i.Paid,
			&i.CostBaisa,
			&i.ChosenDate,
			&i.Complete,
			&i.CreatedAt,
			&i.ExtraPriceChosen,
			&i.ID_2,
			&i.Kind,
			&i.Title,
			&i.TitleAr,
			&i.Subtitle,
			&i.SubtitleAr,
			&i.Description,
			&i.DescriptionAr,
			&i.Photo,
			&i.BasePriceBaisa,
			&i.PlannedDates,
			&i.Photos,
			&i.Longitude,
			&i.Latitude,
			&i.LastUpdated,
			&i.IsDeleted,
			&i.ExtraPriceBaisa,
			&i.ID_3,
			&i.Email,
			&i.Phone,
			&i.Role,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBasicProduct = `-- name: GetBasicProduct :one
SELECT id, kind, title, title_ar, subtitle, subtitle_ar, description, description_ar, photo, base_price_baisa, planned_dates, photos, longitude, latitude, last_updated, is_deleted, extra_price_baisa FROM products WHERE id = $1
`

func (q *Queries) GetBasicProduct(ctx context.Context, id string) (Product, error) {
	row := q.db.QueryRow(ctx, getBasicProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Title,
		&i.TitleAr,
		&i.Subtitle,
		&i.SubtitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.Photo,
		&i.BasePriceBaisa,
		&i.PlannedDates,
		&i.Photos,
		&i.Longitude,
		&i.Latitude,
		&i.LastUpdated,
		&i.IsDeleted,
		&i.ExtraPriceBaisa,
	)
	return i, err
}

const getNotifyPurchaseDetails = `-- name: GetNotifyPurchaseDetails :one
SELECT email, name, product_id, paid, chosen_date, title, (cost_baisa::FLOAT / 1000) as cost
FROM purchases INNER JOIN users ON purchases.user_id = users.id INNER JOIN products ON purchases.product_id = products.id
WHERE purchases.id = $1
`

type GetNotifyPurchaseDetailsRow struct {
	Email      string    `json:"email"`
	Name       string    `json:"name"`
	ProductID  string    `json:"product_id"`
	Paid       bool      `json:"paid"`
	ChosenDate time.Time `json:"chosen_date"`
	Title      string    `json:"title"`
	Cost       int32     `json:"cost"`
}

func (q *Queries) GetNotifyPurchaseDetails(ctx context.Context, id uuid.UUID) (GetNotifyPurchaseDetailsRow, error) {
	row := q.db.QueryRow(ctx, getNotifyPurchaseDetails, id)
	var i GetNotifyPurchaseDetailsRow
	err := row.Scan(
		&i.Email,
		&i.Name,
		&i.ProductID,
		&i.Paid,
		&i.ChosenDate,
		&i.Title,
		&i.Cost,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, kind, title, title_ar, subtitle, subtitle_ar, description, description_ar, photo, base_price_baisa, planned_dates, photos, longitude, latitude, last_updated, is_deleted, extra_price_baisa,
(SELECT COALESCE(COUNT(*), 0) FROM purchases p WHERE p.product_id=$1) purchases_count,
(SELECT COALESCE(SUM(rating)/COUNT(*), 0) as rating FROM reviews r WHERE r.product_id=$1) rating,
(SELECT COALESCE(COUNT(*), 0) as rating_count FROM reviews r WHERE r.product_id=$1) rating_count,
(SELECT COALESCE(COUNT(*), 0) as review_count FROM reviews r WHERE r.product_id = $1 AND title != '') review_count
FROM products WHERE id = $1
`

type GetProductRow struct {
	ID              string      `json:"id"`
	Kind            string      `json:"kind"`
	Title           string      `json:"title"`
	TitleAr         string      `json:"title_ar"`
	Subtitle        string      `json:"subtitle"`
	SubtitleAr      string      `json:"subtitle_ar"`
	Description     string      `json:"description"`
	DescriptionAr   string      `json:"description_ar"`
	Photo           string      `json:"photo"`
	BasePriceBaisa  int64       `json:"base_price_baisa"`
	PlannedDates    []time.Time `json:"planned_dates"`
	Photos          []string    `json:"photos"`
	Longitude       float64     `json:"longitude"`
	Latitude        float64     `json:"latitude"`
	LastUpdated     time.Time   `json:"last_updated"`
	IsDeleted       bool        `json:"is_deleted"`
	ExtraPriceBaisa int64       `json:"extra_price_baisa"`
	PurchasesCount  interface{} `json:"purchases_count"`
	Rating          interface{} `json:"rating"`
	RatingCount     interface{} `json:"rating_count"`
	ReviewCount     interface{} `json:"review_count"`
}

func (q *Queries) GetProduct(ctx context.Context, productID string) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, productID)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Title,
		&i.TitleAr,
		&i.Subtitle,
		&i.SubtitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.Photo,
		&i.BasePriceBaisa,
		&i.PlannedDates,
		&i.Photos,
		&i.Longitude,
		&i.Latitude,
		&i.LastUpdated,
		&i.IsDeleted,
		&i.ExtraPriceBaisa,
		&i.PurchasesCount,
		&i.Rating,
		&i.RatingCount,
		&i.ReviewCount,
	)
	return i, err
}

const getProductReviews = `-- name: GetProductReviews :many
SELECT reviews.product_id, reviews.user_id, reviews.rating, reviews.title, reviews.review, reviews.last_updated, users.name FROM reviews
INNER JOIN users ON reviews.user_id = users.id
WHERE reviews.product_id = $1
ORDER BY last_updated
LIMIT $2::int * 10
OFFSET ($2::int - 1) * 10
`

type GetProductReviewsParams struct {
	ProductID string `json:"product_id"`
	Page      int32  `json:"page"`
}

type GetProductReviewsRow struct {
	ProductID   string    `json:"product_id"`
	UserID      uuid.UUID `json:"user_id"`
	Rating      float64   `json:"rating"`
	Title       string    `json:"title"`
	Review      string    `json:"review"`
	LastUpdated time.Time `json:"last_updated"`
	Name        string    `json:"name"`
}

func (q *Queries) GetProductReviews(ctx context.Context, arg GetProductReviewsParams) ([]GetProductReviewsRow, error) {
	rows, err := q.db.Query(ctx, getProductReviews, arg.ProductID, arg.Page)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductReviewsRow{}
	for rows.Next() {
		var i GetProductReviewsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.UserID,
			&i.Rating,
			&i.Title,
			&i.Review,
			&i.LastUpdated,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProductReview = `-- name: GetUserProductReview :one
SELECT rating, review, last_updated FROM reviews WHERE product_id=$1 AND user_id=$2
`

type GetUserProductReviewParams struct {
	ProductID string    `json:"product_id"`
	UserID    uuid.UUID `json:"user_id"`
}

type GetUserProductReviewRow struct {
	Rating      float64   `json:"rating"`
	Review      string    `json:"review"`
	LastUpdated time.Time `json:"last_updated"`
}

func (q *Queries) GetUserProductReview(ctx context.Context, arg GetUserProductReviewParams) (GetUserProductReviewRow, error) {
	row := q.db.QueryRow(ctx, getUserProductReview, arg.ProductID, arg.UserID)
	var i GetUserProductReviewRow
	err := row.Scan(&i.Rating, &i.Review, &i.LastUpdated)
	return i, err
}

const getUserPurchases = `-- name: GetUserPurchases :many
SELECT purchases.id, product_id, user_id, num_of_participants, paid, cost_baisa, chosen_date, complete, created_at, extra_price_chosen, products.id, kind, title, title_ar, subtitle, subtitle_ar, description, description_ar, photo, base_price_baisa, planned_dates, photos, longitude, latitude, last_updated, is_deleted, extra_price_baisa FROM purchases INNER JOIN products on purchases.product_id = products.id WHERE user_id = $1 AND complete = true ORDER BY purchases.created_at
`

type GetUserPurchasesRow struct {
	ID                uuid.UUID   `json:"id"`
	ProductID         string      `json:"product_id"`
	UserID            uuid.UUID   `json:"user_id"`
	NumOfParticipants int32       `json:"num_of_participants"`
	Paid              bool        `json:"paid"`
	CostBaisa         int64       `json:"cost_baisa"`
	ChosenDate        time.Time   `json:"chosen_date"`
	Complete          bool        `json:"complete"`
	CreatedAt         time.Time   `json:"created_at"`
	ExtraPriceChosen  bool        `json:"extra_price_chosen"`
	ID_2              string      `json:"id_2"`
	Kind              string      `json:"kind"`
	Title             string      `json:"title"`
	TitleAr           string      `json:"title_ar"`
	Subtitle          string      `json:"subtitle"`
	SubtitleAr        string      `json:"subtitle_ar"`
	Description       string      `json:"description"`
	DescriptionAr     string      `json:"description_ar"`
	Photo             string      `json:"photo"`
	BasePriceBaisa    int64       `json:"base_price_baisa"`
	PlannedDates      []time.Time `json:"planned_dates"`
	Photos            []string    `json:"photos"`
	Longitude         float64     `json:"longitude"`
	Latitude          float64     `json:"latitude"`
	LastUpdated       time.Time   `json:"last_updated"`
	IsDeleted         bool        `json:"is_deleted"`
	ExtraPriceBaisa   int64       `json:"extra_price_baisa"`
}

func (q *Queries) GetUserPurchases(ctx context.Context, userID uuid.UUID) ([]GetUserPurchasesRow, error) {
	rows, err := q.db.Query(ctx, getUserPurchases, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPurchasesRow{}
	for rows.Next() {
		var i GetUserPurchasesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.NumOfParticipants,
			&i.Paid,
			&i.CostBaisa,
			&i.ChosenDate,
			&i.Complete,
			&i.CreatedAt,
			&i.ExtraPriceChosen,
			&i.ID_2,
			&i.Kind,
			&i.Title,
			&i.TitleAr,
			&i.Subtitle,
			&i.SubtitleAr,
			&i.Description,
			&i.DescriptionAr,
			&i.Photo,
			&i.BasePriceBaisa,
			&i.PlannedDates,
			&i.Photos,
			&i.Longitude,
			&i.Latitude,
			&i.LastUpdated,
			&i.IsDeleted,
			&i.ExtraPriceBaisa,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPurchase = `-- name: InsertPurchase :exec
INSERT INTO purchases(id, product_id, user_id, num_of_participants, paid, cost_baisa, chosen_date, complete, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_DATE)
`

type InsertPurchaseParams struct {
	ID                uuid.UUID `json:"id"`
	ProductID         string    `json:"product_id"`
	UserID            uuid.UUID `json:"user_id"`
	NumOfParticipants int32     `json:"num_of_participants"`
	Paid              bool      `json:"paid"`
	CostBaisa         int64     `json:"cost_baisa"`
	ChosenDate        time.Time `json:"chosen_date"`
	Complete          bool      `json:"complete"`
}

func (q *Queries) InsertPurchase(ctx context.Context, arg InsertPurchaseParams) error {
	_, err := q.db.Exec(ctx, insertPurchase,
		arg.ID,
		arg.ProductID,
		arg.UserID,
		arg.NumOfParticipants,
		arg.Paid,
		arg.CostBaisa,
		arg.ChosenDate,
		arg.Complete,
	)
	return err
}

const reviewProduct = `-- name: ReviewProduct :exec
INSERT INTO reviews(product_id, user_id, rating, title, review, last_updated)
VALUES ($1, $2, $3, $4, $5, CURRENT_DATE) ON CONFLICT (product_id, user_id)
DO UPDATE SET
  rating = excluded.rating,
  title = excluded.title,
  review = excluded.review,
  last_updated = excluded.last_updated
`

type ReviewProductParams struct {
	ProductID string    `json:"product_id"`
	UserID    uuid.UUID `json:"user_id"`
	Rating    float64   `json:"rating"`
	Title     string    `json:"title"`
	Review    string    `json:"review"`
}

func (q *Queries) ReviewProduct(ctx context.Context, arg ReviewProductParams) error {
	_, err := q.db.Exec(ctx, reviewProduct,
		arg.ProductID,
		arg.UserID,
		arg.Rating,
		arg.Title,
		arg.Review,
	)
	return err
}

const upsertProduct = `-- name: UpsertProduct :exec
INSERT INTO products(
  id,
  kind,
  title,
  title_ar,
  subtitle,
  subtitle_ar,
  description,
  description_ar,
  photo,
  base_price_baisa,
  extra_price_baisa,
  planned_dates,
  photos,
  longitude,
  latitude,
  last_updated,
  is_deleted
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, CURRENT_DATE, false)
ON CONFLICT (id) DO UPDATE SET
  title = excluded.title,
  title_ar = excluded.title_ar,
  subtitle = excluded.subtitle,
  subtitle_ar = excluded.subtitle_ar,
  description = excluded.description,
  description_ar = excluded.description_ar,
  photo = excluded.photo,
  base_price_baisa = excluded.base_price_baisa,
  extra_price_baisa = excluded.extra_price_baisa,
  planned_dates = excluded.planned_dates,
  photos = excluded.photos,
  longitude = excluded.longitude,
  latitude = excluded.latitude,
  is_deleted = excluded.is_deleted,
  last_updated = CURRENT_DATE
`

type UpsertProductParams struct {
	ID              string      `json:"id"`
	Kind            string      `json:"kind"`
	Title           string      `json:"title"`
	TitleAr         string      `json:"title_ar"`
	Subtitle        string      `json:"subtitle"`
	SubtitleAr      string      `json:"subtitle_ar"`
	Description     string      `json:"description"`
	DescriptionAr   string      `json:"description_ar"`
	Photo           string      `json:"photo"`
	BasePriceBaisa  int64       `json:"base_price_baisa"`
	ExtraPriceBaisa int64       `json:"extra_price_baisa"`
	PlannedDates    []time.Time `json:"planned_dates"`
	Photos          []string    `json:"photos"`
	Longitude       float64     `json:"longitude"`
	Latitude        float64     `json:"latitude"`
}

func (q *Queries) UpsertProduct(ctx context.Context, arg UpsertProductParams) error {
	_, err := q.db.Exec(ctx, upsertProduct,
		arg.ID,
		arg.Kind,
		arg.Title,
		arg.TitleAr,
		arg.Subtitle,
		arg.SubtitleAr,
		arg.Description,
		arg.DescriptionAr,
		arg.Photo,
		arg.BasePriceBaisa,
		arg.ExtraPriceBaisa,
		arg.PlannedDates,
		arg.Photos,
		arg.Longitude,
		arg.Latitude,
	)
	return err
}

const userCanRateProduct = `-- name: UserCanRateProduct :one
SELECT EXISTS (
  SELECT 1 FROM purchases WHERE user_id = $1 AND product_id = $2 AND chosen_date > CURRENT_DATE
)
`

type UserCanRateProductParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID string    `json:"product_id"`
}

func (q *Queries) UserCanRateProduct(ctx context.Context, arg UserCanRateProductParams) (bool, error) {
	row := q.db.QueryRow(ctx, userCanRateProduct, arg.UserID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
