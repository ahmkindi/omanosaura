// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: trips.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllTrips = `-- name: GetAllTrips :many
SELECT products.id, kind, title, title_ar, description, description_ar, photo, price_baisa, last_udpated, trips.id, subtitle, subtitle_ar, photos FROM products NATURAL JOIN trips
`

type GetAllTripsRow struct {
	ID            uuid.UUID `json:"id"`
	Kind          string    `json:"kind"`
	Title         string    `json:"title"`
	TitleAr       string    `json:"title_ar"`
	Description   string    `json:"description"`
	DescriptionAr string    `json:"description_ar"`
	Photo         string    `json:"photo"`
	PriceBaisa    int32     `json:"price_baisa"`
	LastUdpated   time.Time `json:"last_udpated"`
	ID_2          uuid.UUID `json:"id_2"`
	Subtitle      string    `json:"subtitle"`
	SubtitleAr    string    `json:"subtitle_ar"`
	Photos        []string  `json:"photos"`
}

func (q *Queries) GetAllTrips(ctx context.Context) ([]GetAllTripsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTrips)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTripsRow{}
	for rows.Next() {
		var i GetAllTripsRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Title,
			&i.TitleAr,
			&i.Description,
			&i.DescriptionAr,
			&i.Photo,
			&i.PriceBaisa,
			&i.LastUdpated,
			&i.ID_2,
			&i.Subtitle,
			&i.SubtitleAr,
			pq.Array(&i.Photos),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrip = `-- name: GetTrip :one
SELECT products.id, kind, title, title_ar, description, description_ar, photo, price_baisa, last_udpated, t.id, t.subtitle, t.subtitle_ar, t.photos, trips.id, trips.subtitle, trips.subtitle_ar, trips.photos, r.product_id, r.user_id, r.review, r.last_updated, reviews.product_id, reviews.user_id, reviews.review, reviews.last_updated, users.id, email, firstname, lastname, phone, (SELECT SUM(rating)/COUNT(*) FROM ratings WHERE ratings.product_id = $1) likes FROM products NATURAL JOIN (SELECT id, subtitle, subtitle_ar, photos FROM trips WHERE trips.id = $1) t
INNER JOIN (SELECT product_id, user_id, review, last_updated FROM reviews WHERE product_id = $1) r ON t.id = product_id
INNER JOIN users ON r.user_id = users.id
`

type GetTripRow struct {
	ID            uuid.UUID   `json:"id"`
	Kind          string      `json:"kind"`
	Title         string      `json:"title"`
	TitleAr       string      `json:"title_ar"`
	Description   string      `json:"description"`
	DescriptionAr string      `json:"description_ar"`
	Photo         string      `json:"photo"`
	PriceBaisa    int32       `json:"price_baisa"`
	LastUdpated   time.Time   `json:"last_udpated"`
	ID_2          uuid.UUID   `json:"id_2"`
	Subtitle      string      `json:"subtitle"`
	SubtitleAr    string      `json:"subtitle_ar"`
	Photos        []string    `json:"photos"`
	ID_3          uuid.UUID   `json:"id_3"`
	Subtitle_2    string      `json:"subtitle_2"`
	SubtitleAr_2  string      `json:"subtitle_ar_2"`
	Photos_2      []string    `json:"photos_2"`
	ProductID     uuid.UUID   `json:"product_id"`
	UserID        uuid.UUID   `json:"user_id"`
	Review        string      `json:"review"`
	LastUpdated   time.Time   `json:"last_updated"`
	ProductID_2   uuid.UUID   `json:"product_id_2"`
	UserID_2      uuid.UUID   `json:"user_id_2"`
	Review_2      string      `json:"review_2"`
	LastUpdated_2 time.Time   `json:"last_updated_2"`
	ID_4          uuid.UUID   `json:"id_4"`
	Email         interface{} `json:"email"`
	Firstname     string      `json:"firstname"`
	Lastname      string      `json:"lastname"`
	Phone         string      `json:"phone"`
	Likes         int32       `json:"likes"`
}

func (q *Queries) GetTrip(ctx context.Context, productID uuid.UUID) (GetTripRow, error) {
	row := q.db.QueryRowContext(ctx, getTrip, productID)
	var i GetTripRow
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Title,
		&i.TitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.Photo,
		&i.PriceBaisa,
		&i.LastUdpated,
		&i.ID_2,
		&i.Subtitle,
		&i.SubtitleAr,
		pq.Array(&i.Photos),
		&i.ID_3,
		&i.Subtitle_2,
		&i.SubtitleAr_2,
		pq.Array(&i.Photos_2),
		&i.ProductID,
		&i.UserID,
		&i.Review,
		&i.LastUpdated,
		&i.ProductID_2,
		&i.UserID_2,
		&i.Review_2,
		&i.LastUpdated_2,
		&i.ID_4,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
		&i.Phone,
		&i.Likes,
	)
	return i, err
}

const upsertTrip = `-- name: UpsertTrip :exec
WITH upsert_product AS (
  INSERT INTO products(id, kind, title, title_ar, description, description_ar, photo, price_baisa)
  VALUES ($1, 'T', $2, $3, $4, $5, $6, $7)
  ON CONFLICT (id) DO UPDATE SET
    title = excluded.title,
    title_ar = excluded.title_ar,
    description = excluded.description,
    description_ar = excluded.description_ar,
    photo = excluded.photo,
    price_baisa = excluded.price_baisa
)
INSERT INTO trips(id, subtitle, subtitle_ar, photos)
VALUES ($1, $8, $9, $10)
ON CONFLICT (id) DO UPDATE SET
	subtitle = excluded.subtitle,
	subtitle_ar = excluded.subtitle_ar,
  photos = excluded.photos
`

type UpsertTripParams struct {
	ID            uuid.UUID `json:"id"`
	Title         string    `json:"title"`
	TitleAr       string    `json:"title_ar"`
	Description   string    `json:"description"`
	DescriptionAr string    `json:"description_ar"`
	Photo         string    `json:"photo"`
	PriceBaisa    int32     `json:"price_baisa"`
	Subtitle      string    `json:"subtitle"`
	SubtitleAr    string    `json:"subtitle_ar"`
	Photos        []string  `json:"photos"`
}

func (q *Queries) UpsertTrip(ctx context.Context, arg UpsertTripParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrip,
		arg.ID,
		arg.Title,
		arg.TitleAr,
		arg.Description,
		arg.DescriptionAr,
		arg.Photo,
		arg.PriceBaisa,
		arg.Subtitle,
		arg.SubtitleAr,
		pq.Array(arg.Photos),
	)
	return err
}
